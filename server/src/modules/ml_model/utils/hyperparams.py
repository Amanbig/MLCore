"""
Hyperparameter schemas sourced from sklearn defaults.
Each entry describes one param with enough metadata for the frontend
to render a proper form field.

Field types:
  int    → integer number input (min/max optional)
  float  → float number input (min/max optional)
  bool   → toggle / checkbox
  select → dropdown (options list required)
  str    → free-text input
"""

# from typing import Any

HyperparamDef = dict  # {name, type, default, description, [min, max, options, nullable]}


HYPERPARAMETER_SCHEMAS: dict[str, list[HyperparamDef]] = {
    # ── Classifiers ──────────────────────────────────────────────────────
    "random_forest_classifier": [
        {
            "name": "n_estimators",
            "type": "int",
            "default": 100,
            "min": 1,
            "max": 2000,
            "description": "Number of trees in the forest.",
        },
        {
            "name": "max_depth",
            "type": "int",
            "default": None,
            "min": 1,
            "max": 100,
            "nullable": True,
            "description": "Max depth of each tree. Leave empty for unlimited.",
        },
        {
            "name": "min_samples_split",
            "type": "int",
            "default": 2,
            "min": 2,
            "max": 50,
            "description": "Min samples required to split an internal node.",
        },
        {
            "name": "min_samples_leaf",
            "type": "int",
            "default": 1,
            "min": 1,
            "max": 50,
            "description": "Min samples required to be at a leaf node.",
        },
        {
            "name": "max_features",
            "type": "select",
            "default": "sqrt",
            "options": ["sqrt", "log2", "None"],
            "description": "Number of features to consider for best split.",
        },
        {
            "name": "bootstrap",
            "type": "bool",
            "default": True,
            "description": "Whether to use bootstrap samples when building trees.",
        },
        {
            "name": "random_state",
            "type": "int",
            "default": 42,
            "min": 0,
            "max": 99999,
            "description": "Random seed for reproducibility.",
        },
    ],
    "logistic_regression": [
        {
            "name": "C",
            "type": "float",
            "default": 1.0,
            "min": 0.0001,
            "max": 1000.0,
            "description": "Inverse of regularization strength. Smaller = stronger regularization.",
        },
        {
            "name": "max_iter",
            "type": "int",
            "default": 100,
            "min": 10,
            "max": 10000,
            "description": "Maximum number of iterations for solver.",
        },
        {
            "name": "solver",
            "type": "select",
            "default": "lbfgs",
            "options": ["lbfgs", "liblinear", "newton-cg", "newton-cholesky", "sag", "saga"],
            "description": "Algorithm to use in the optimization problem.",
        },
        {
            "name": "penalty",
            "type": "select",
            "default": "l2",
            "options": ["l1", "l2", "elasticnet", "None"],
            "description": "Regularization norm.",
        },
        {
            "name": "fit_intercept",
            "type": "bool",
            "default": True,
            "description": "Whether to add a bias/intercept term.",
        },
    ],
    "svm": [
        {
            "name": "C",
            "type": "float",
            "default": 1.0,
            "min": 0.0001,
            "max": 1000.0,
            "description": "Regularization parameter. Higher = less regularization.",
        },
        {
            "name": "kernel",
            "type": "select",
            "default": "rbf",
            "options": ["linear", "poly", "rbf", "sigmoid"],
            "description": "Kernel function for the SVM.",
        },
        {
            "name": "degree",
            "type": "int",
            "default": 3,
            "min": 1,
            "max": 10,
            "description": "Degree of polynomial kernel (only used when kernel='poly').",
        },
        {
            "name": "gamma",
            "type": "select",
            "default": "scale",
            "options": ["scale", "auto"],
            "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.",
        },
        {
            "name": "max_iter",
            "type": "int",
            "default": -1,
            "min": -1,
            "max": 100000,
            "description": "Hard limit on iterations (-1 = no limit).",
        },
    ],
    "decision_tree": [
        {
            "name": "max_depth",
            "type": "int",
            "default": None,
            "min": 1,
            "max": 100,
            "nullable": True,
            "description": "Max depth of the tree. Leave empty for unlimited.",
        },
        {
            "name": "min_samples_split",
            "type": "int",
            "default": 2,
            "min": 2,
            "max": 50,
            "description": "Min samples required to split an internal node.",
        },
        {
            "name": "min_samples_leaf",
            "type": "int",
            "default": 1,
            "min": 1,
            "max": 50,
            "description": "Min samples required to be at a leaf node.",
        },
        {
            "name": "criterion",
            "type": "select",
            "default": "gini",
            "options": ["gini", "entropy", "log_loss"],
            "description": "Function to measure quality of split.",
        },
        {
            "name": "max_features",
            "type": "select",
            "default": "None",
            "options": ["sqrt", "log2", "None"],
            "description": "Number of features to consider for best split.",
        },
        {
            "name": "random_state",
            "type": "int",
            "default": 42,
            "min": 0,
            "max": 99999,
            "description": "Random seed for reproducibility.",
        },
    ],
    "gradient_boosting": [
        {
            "name": "n_estimators",
            "type": "int",
            "default": 100,
            "min": 1,
            "max": 2000,
            "description": "Number of boosting stages.",
        },
        {
            "name": "learning_rate",
            "type": "float",
            "default": 0.1,
            "min": 0.001,
            "max": 1.0,
            "description": "Shrinks contribution of each tree.",
        },
        {
            "name": "max_depth",
            "type": "int",
            "default": 3,
            "min": 1,
            "max": 20,
            "description": "Max depth of each individual tree.",
        },
        {
            "name": "min_samples_split",
            "type": "int",
            "default": 2,
            "min": 2,
            "max": 50,
            "description": "Min samples required to split a node.",
        },
        {
            "name": "subsample",
            "type": "float",
            "default": 1.0,
            "min": 0.1,
            "max": 1.0,
            "description": "Fraction of samples used for fitting each tree.",
        },
        {
            "name": "random_state",
            "type": "int",
            "default": 42,
            "min": 0,
            "max": 99999,
            "description": "Random seed for reproducibility.",
        },
    ],
    "knn": [
        {
            "name": "n_neighbors",
            "type": "int",
            "default": 5,
            "min": 1,
            "max": 200,
            "description": "Number of neighbors to use.",
        },
        {
            "name": "weights",
            "type": "select",
            "default": "uniform",
            "options": ["uniform", "distance"],
            "description": "Weight function used in prediction.",
        },
        {
            "name": "algorithm",
            "type": "select",
            "default": "auto",
            "options": ["auto", "ball_tree", "kd_tree", "brute"],
            "description": "Algorithm used to compute nearest neighbors.",
        },
        {
            "name": "metric",
            "type": "select",
            "default": "minkowski",
            "options": ["minkowski", "euclidean", "manhattan", "chebyshev"],
            "description": "Distance metric to use.",
        },
        {
            "name": "p",
            "type": "int",
            "default": 2,
            "min": 1,
            "max": 10,
            "description": "Power parameter for Minkowski metric (2 = Euclidean).",
        },
    ],
    "naive_bayes": [
        {
            "name": "var_smoothing",
            "type": "float",
            "default": 1e-9,
            "min": 1e-15,
            "max": 1.0,
            "description": "Portion of the largest variance added to variances for stability.",
        },
    ],
    # ── Regressors ───────────────────────────────────────────────────────
    "linear_regression": [
        {
            "name": "fit_intercept",
            "type": "bool",
            "default": True,
            "description": "Whether to calculate the intercept for the model.",
        },
        {
            "name": "positive",
            "type": "bool",
            "default": False,
            "description": "When True, forces coefficients to be positive.",
        },
    ],
    "random_forest_regressor": [
        {
            "name": "n_estimators",
            "type": "int",
            "default": 100,
            "min": 1,
            "max": 2000,
            "description": "Number of trees in the forest.",
        },
        {
            "name": "max_depth",
            "type": "int",
            "default": None,
            "min": 1,
            "max": 100,
            "nullable": True,
            "description": "Max depth of each tree. Leave empty for unlimited.",
        },
        {
            "name": "min_samples_split",
            "type": "int",
            "default": 2,
            "min": 2,
            "max": 50,
            "description": "Min samples required to split an internal node.",
        },
        {
            "name": "min_samples_leaf",
            "type": "int",
            "default": 1,
            "min": 1,
            "max": 50,
            "description": "Min samples required to be at a leaf node.",
        },
        {
            "name": "max_features",
            "type": "select",
            "default": "1.0",
            "options": ["1.0", "sqrt", "log2"],
            "description": "Number of features to consider for best split.",
        },
        {
            "name": "bootstrap",
            "type": "bool",
            "default": True,
            "description": "Whether to use bootstrap samples when building trees.",
        },
        {
            "name": "random_state",
            "type": "int",
            "default": 42,
            "min": 0,
            "max": 99999,
            "description": "Random seed for reproducibility.",
        },
    ],
    "ridge": [
        {
            "name": "alpha",
            "type": "float",
            "default": 1.0,
            "min": 0.0,
            "max": 1000.0,
            "description": "Regularization strength. Higher = stronger regularization.",
        },
        {
            "name": "fit_intercept",
            "type": "bool",
            "default": True,
            "description": "Whether to fit the intercept term.",
        },
        {
            "name": "max_iter",
            "type": "int",
            "default": None,
            "min": 1,
            "max": 100000,
            "nullable": True,
            "description": "Max iterations for conjugate gradient solver.",
        },
        {
            "name": "solver",
            "type": "select",
            "default": "auto",
            "options": ["auto", "svd", "cholesky", "lsqr", "sparse_cg", "sag", "saga"],
            "description": "Solver to use in the computational routines.",
        },
    ],
    "lasso": [
        {
            "name": "alpha",
            "type": "float",
            "default": 1.0,
            "min": 0.0,
            "max": 1000.0,
            "description": "Regularization strength. Higher = stronger regularization.",
        },
        {
            "name": "fit_intercept",
            "type": "bool",
            "default": True,
            "description": "Whether to fit the intercept term.",
        },
        {
            "name": "max_iter",
            "type": "int",
            "default": 1000,
            "min": 10,
            "max": 100000,
            "description": "Maximum number of iterations.",
        },
        {
            "name": "selection",
            "type": "select",
            "default": "cyclic",
            "options": ["cyclic", "random"],
            "description": "Strategy to choose the coordinate to update at each iteration.",
        },
    ],
    "svr": [
        {
            "name": "C",
            "type": "float",
            "default": 1.0,
            "min": 0.0001,
            "max": 1000.0,
            "description": "Regularization parameter.",
        },
        {
            "name": "kernel",
            "type": "select",
            "default": "rbf",
            "options": ["linear", "poly", "rbf", "sigmoid"],
            "description": "Kernel function for the SVR.",
        },
        {
            "name": "degree",
            "type": "int",
            "default": 3,
            "min": 1,
            "max": 10,
            "description": "Degree of polynomial kernel (only used when kernel='poly').",
        },
        {
            "name": "gamma",
            "type": "select",
            "default": "scale",
            "options": ["scale", "auto"],
            "description": "Kernel coefficient.",
        },
        {
            "name": "epsilon",
            "type": "float",
            "default": 0.1,
            "min": 0.0,
            "max": 10.0,
            "description": "Epsilon in the epsilon-SVR model (no penalty for points within epsilon).",
        },
        {
            "name": "max_iter",
            "type": "int",
            "default": -1,
            "min": -1,
            "max": 100000,
            "description": "Hard limit on iterations (-1 = no limit).",
        },
    ],
    "decision_tree_regressor": [
        {
            "name": "max_depth",
            "type": "int",
            "default": None,
            "min": 1,
            "max": 100,
            "nullable": True,
            "description": "Max depth of the tree. Leave empty for unlimited.",
        },
        {
            "name": "min_samples_split",
            "type": "int",
            "default": 2,
            "min": 2,
            "max": 50,
            "description": "Min samples required to split an internal node.",
        },
        {
            "name": "min_samples_leaf",
            "type": "int",
            "default": 1,
            "min": 1,
            "max": 50,
            "description": "Min samples required to be at a leaf node.",
        },
        {
            "name": "criterion",
            "type": "select",
            "default": "squared_error",
            "options": ["squared_error", "friedman_mse", "absolute_error", "poisson"],
            "description": "Function to measure quality of split.",
        },
        {
            "name": "random_state",
            "type": "int",
            "default": 42,
            "min": 0,
            "max": 99999,
            "description": "Random seed for reproducibility.",
        },
    ],
    "gradient_boosting_regressor": [
        {
            "name": "n_estimators",
            "type": "int",
            "default": 100,
            "min": 1,
            "max": 2000,
            "description": "Number of boosting stages.",
        },
        {
            "name": "learning_rate",
            "type": "float",
            "default": 0.1,
            "min": 0.001,
            "max": 1.0,
            "description": "Shrinks contribution of each tree.",
        },
        {
            "name": "max_depth",
            "type": "int",
            "default": 3,
            "min": 1,
            "max": 20,
            "description": "Max depth of each individual tree.",
        },
        {
            "name": "subsample",
            "type": "float",
            "default": 1.0,
            "min": 0.1,
            "max": 1.0,
            "description": "Fraction of samples used for fitting each tree.",
        },
        {
            "name": "loss",
            "type": "select",
            "default": "squared_error",
            "options": ["squared_error", "absolute_error", "huber", "quantile"],
            "description": "Loss function to be optimized.",
        },
        {
            "name": "random_state",
            "type": "int",
            "default": 42,
            "min": 0,
            "max": 99999,
            "description": "Random seed for reproducibility.",
        },
    ],
}


def get_hyperparams(algorithm: str) -> list[HyperparamDef]:
    """Return the hyperparameter schema list for the given algorithm key."""
    # Normalise common aliases
    alias_map = {
        "randomforestclassifier": "random_forest_classifier",
        "random_forest": "random_forest_classifier",
        "logisticregression": "logistic_regression",
        "svc": "svm",
        "support_vector_machine": "svm",
        "decisiontreeclassifier": "decision_tree",
        "decision_tree_classifier": "decision_tree",
        "gradientboostingclassifier": "gradient_boosting",
        "gradient_boosting_classifier": "gradient_boosting",
        "kneighbors": "knn",
        "k_nearest_neighbors": "knn",
        "gaussiannb": "naive_bayes",
        "gaussian_naive_bayes": "naive_bayes",
        "linearregression": "linear_regression",
        "randomforestregressor": "random_forest_regressor",
        "ridge_regression": "ridge",
        "lasso_regression": "lasso",
        "svr": "svr",
        "support_vector_regressor": "svr",
        "decisiontreeregressor": "decision_tree_regressor",
        "gradientboostingregressor": "gradient_boosting_regressor",
        "gradient_boosting_regressor": "gradient_boosting_regressor",
    }
    key = alias_map.get(algorithm.lower(), algorithm.lower())
    return HYPERPARAMETER_SCHEMAS.get(key, [])
